<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <title>r-world – Firebase Pixel mit smooth Zoom & Pan</title>
  <style>
    body { margin:0; overflow:hidden; background:#111; font-family:sans-serif; }
    #canvas {
      width:100vw; height:100vh; display:block;
      background:#eee; touch-action: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    #colors {
      position: fixed; top: 12px; left: 12px; z-index: 100;
      background: rgba(255,255,255,0.92); padding: 8px;
      border-radius: 10px; box-shadow: 0 2px 12px rgba(0,0,0,0.25);
    }
    #colors button {
      width: 32px; height: 32px; margin: 4px;
      border: 2px solid #fff; border-radius: 6px;
      cursor: pointer; box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>

<div id="colors"></div>
<canvas id="canvas"></canvas>

<script type="module">
// ===== Firebase Setup =====
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, setDoc, collection, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCXNvSbBsRVgyKJUmckxpm_WHhC6xflSTg",
  authDomain: "r-world-3879d.firebaseapp.com",
  projectId: "r-world-3879d",
  storageBucket: "r-world-3879d.appspot.com",
  messagingSenderId: "878075356607",
  appId: "1:878075356607:web:c2177f3904858d50626d0a"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// ===== Canvas & Vars =====
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const PIXEL = 40;
let currentColor = "#000000";
const pixels = new Map();

// Viewport / Transformation
let scale     = 1;
let offsetX   = 0;
let offsetY   = 0;
let isDirty   = true;   // nur neu zeichnen wenn nötig

// Resize
function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
  isDirty = true;
}
window.addEventListener('resize', resize);
resize();

// Farbpalette
const palette = ["#000","#f00","#0f0","#00f","#ff0","#f0f","#0ff","#fff","#888","#fa0","#0fa","#a0f"];
const colorDiv = document.getElementById('colors');
palette.forEach(c => {
  const b = document.createElement('button');
  b.style.background = c;
  b.onclick = () => currentColor = c;
  colorDiv.appendChild(b);
});

// ===== Zeichnen (mit requestAnimationFrame) =====
function draw() {
  if (!isDirty) {
    requestAnimationFrame(draw);
    return;
  }
  isDirty = false;

  ctx.setTransform(1,0,0,1,0,0);           // Reset
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  // Hintergrund
  ctx.fillStyle = "#eee";
  ctx.fillRect(0, 0, canvas.width/scale, canvas.height/scale);

  // Grid
  ctx.strokeStyle = scale > 0.8 ? "#ccc" : "#ddd";
  ctx.lineWidth = 1 / scale;
  const left   = -offsetX / scale;
  const top    = -offsetY / scale;
  const right  = left + canvas.width  / scale;
  const bottom = top  + canvas.height / scale;

  const xStart = Math.floor(left  / PIXEL) * PIXEL;
  const yStart = Math.floor(top   / PIXEL) * PIXEL;

  for (let x = xStart; x < right; x += PIXEL) {
    ctx.beginPath();
    ctx.moveTo(x, top);
    ctx.lineTo(x, bottom);
    ctx.stroke();
  }
  for (let y = yStart; y < bottom; y += PIXEL) {
    ctx.beginPath();
    ctx.moveTo(left, y);
    ctx.lineTo(right, y);
    ctx.stroke();
  }

  // Pixel
  pixels.forEach((color, key) => {
    const [px, py] = key.split('_').map(Number);
    ctx.fillStyle = color;
    ctx.fillRect(px * PIXEL + 1, py * PIXEL + 1, PIXEL - 2, PIXEL - 2);
  });

  ctx.restore();

  requestAnimationFrame(draw);
}
draw();

// ===== Firebase =====
onSnapshot(collection(db, "pixels"), snap => {
  snap.docChanges().forEach(change => {
    if (change.type === "added" || change.type === "modified") {
      const d = change.doc.data();
      pixels.set(`${d.x}_${d.y}`, d.color);
    }
  });
  isDirty = true;
});

// ===== Hilfsfunktion: Screen → World Koordinate =====
function screenToWorld(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const sx = clientX - rect.left;
  const sy = clientY - rect.top;
  return {
    x: (sx - offsetX) / scale / PIXEL,
    y: (sy - offsetY) / scale / PIXEL
  };
}

// ===== Pixel platzieren =====
function placePixel(clientX, clientY) {
  const {x, y} = screenToWorld(clientX, clientY);
  const ix = Math.floor(x);
  const iy = Math.floor(y);
  const id = `${ix}_${iy}`;

  setDoc(doc(db, "pixels", id), {
    x: ix,
    y: iy,
    color: currentColor,
    time: serverTimestamp()
  }).catch(err => console.error(err));
}

// ===== Touch handling (Pinch + Pan + Draw) =====
let lastTouches = null;

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  lastTouches = [...e.touches];
}, {passive: false});

canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  const touches = e.touches;

  if (touches.length === 1) {
    // Einzelner Finger → malen
    placePixel(touches[0].clientX, touches[0].clientY);
    isDirty = true;
  }
  else if (touches.length === 2 && lastTouches?.length === 2) {
    // Pinch + Pan mit zwei Fingern
    const [t1, t2]     = touches;
    const [p1, p2]     = lastTouches;

    const midX = (t1.clientX + t2.clientX) / 2;
    const midY = (t1.clientY + t2.clientY) / 2;
    const prevMidX = (p1.clientX + p2.clientX) / 2;
    const prevMidY = (p1.clientY + p2.clientY) / 2;

    // Zoom
    const distOld = Math.hypot(p2.clientX - p1.clientX, p2.clientY - p1.clientY);
    const distNew = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);

    if (distOld > 4) {   // vermeide Rauschen bei fast gleicher Position
      const zoom = distNew / distOld;
      const oldScale = scale;
      scale *= zoom ** 0.85;   // etwas sanfter
      scale = Math.max(0.25, Math.min(12, scale));

      // Zoom zum Mittelpunkt der Finger
      offsetX = midX - (midX - offsetX) * (scale / oldScale);
      offsetY = midY - (midY - offsetY) * (scale / oldScale);
    }

    // Pan (auch bei sehr kleinem Pinch)
    offsetX += (midX - prevMidX);
    offsetY += (midY - prevMidY);

    isDirty = true;
    lastTouches = [...touches];
  }
}, {passive: false});

canvas.addEventListener("touchend", e => {
  if (e.touches.length < 2) lastTouches = null;
});

// ===== Mouse (Desktop) =====
let isDrawing = false;
let lastMouseX = 0, lastMouseY = 0;

canvas.addEventListener("mousedown", e => {
  if (e.button === 0) {
    isDrawing = true;
    placePixel(e.clientX, e.clientY);
    isDirty = true;
  }
});

canvas.addEventListener("mousemove", e => {
  if (isDrawing) {
    placePixel(e.clientX, e.clientY);
    isDirty = true;
  }
});

canvas.addEventListener("mouseup",   () => isDrawing = false);
canvas.addEventListener("mouseleave", () => isDrawing = false);

// Wheel Zoom (auch Ctrl + Scroll auf Trackpad / Maus)
canvas.addEventListener("wheel", e => {
  e.preventDefault();

  const delta = e.deltaY < 0 ? 1.12 : 0.88;
  const oldScale = scale;
  scale *= delta;
  scale = Math.max(0.25, Math.min(12, scale));

  // Zoom zur Mausposition
  const mx = e.clientX - canvas.getBoundingClientRect().left;
  const my = e.clientY - canvas.getBoundingClientRect().top;

  offsetX = mx - (mx - offsetX) * (scale / oldScale);
  offsetY = my - (my - offsetY) * (scale / oldScale);

  isDirty = true;
}, {passive: false});

</script>
</body>
</html>
