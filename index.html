<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <title>r-world â€“ Pixel Art ohne Login</title>
  <style>
    body {
      margin:0; overflow:hidden; background:#f4f7fb;
      font-family: system-ui, sans-serif; color:#444;
    }
    #canvas {
      width:100vw; height:100vh; display:block;
      background:#e9f1ff; touch-action: none;
      -webkit-user-select: none;
      cursor: default;
    }
    #gui {
      position: fixed; top: 12px; left: 12px; z-index: 100;
      background: rgba(255,255,255,0.97);
      padding: 12px 16px;
      border-radius: 14px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      border: 1px solid #e0e0e0;
      min-width: 220px;
      max-width: 260px;
    }
    #colors {
      display: grid;
      grid-template-columns: repeat(4, 42px);
      gap: 10px;
      margin: 12px 0 8px;
    }
    #colors button {
      width: 42px; height: 42px;
      border: 3px solid #f0f0f0;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transition: all 0.14s;
    }
    #colors button:hover { transform: scale(1.12); border-color: #ccc; }
    #colors button.selected {
      border-color: #1a73e8;
      box-shadow: 0 0 0 3px rgba(26,115,232,0.25);
      transform: scale(1.08);
    }
    #status { font-size: 0.92rem; color: #666; min-height: 1.3em; margin-top: 8px; }
    .control-btn {
      display: block; width: 100%; padding: 8px; margin: 6px 0;
      background: #f0f0f0; border: 1px solid #ccc; border-radius: 8px;
      font-size: 0.9rem; cursor: pointer;
    }
    .control-btn:hover { background: #e0e0e0; }
    #player-info { font-size: 0.88rem; line-height: 1.45; margin: 10px 0; }
  </style>
</head>
<body>
<div id="gui">
  <div><strong>Farbe</strong></div>
  <div id="colors"></div>
  <div id="status">Bereit zum Pixeln!</div>
</div>
<canvas id="canvas"></canvas>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, setDoc, deleteDoc, collection, onSnapshot, serverTimestamp, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyCXNvSbBsRVgyKJUmckxpm_WHhC6xflSTg",
  authDomain: "r-world-3879d.firebaseapp.com",
  projectId: "r-world-3879d",
  storageBucket: "r-world-3879d.appspot.com",
  messagingSenderId: "878075356607",
  appId: "1:878075356607:web:c2177f3904858d50626d0a"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

// ===== Canvas & Vars =====
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');
const PIXEL = 32;
const WORLD_MIN = -125;   // 250Ã—250 Karte
const WORLD_MAX = 124;
let currentColor = "#000000";
let isEraser = false;
const pixels = new Map(); // "x_y" â†’ color

// Viewport
let scale = 1;
let offsetX = 0;
let offsetY = 0;
let isDirty = true;

// Pixel-Modus (Viewport locked)
let isPixelMode = false;

// User & Level-System
let currentUser = null;
let userDocRef = null;
let userData = { level: 1, maxPixels: 10, placed: 0, coins: 0, cooldown: 5000, lastPlace: null };

// Resize
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  isDirty = true;
}
window.addEventListener('resize', resize);
resize();

// Farbpalette
const palette = ["#000","#fff","#f00","#0f0","#00f","#ff0","#f0f","#0ff","#fa0","#0fa","#a0f","#f80","#c71585","#32cd32","#4169e1","#808080"];
const colorDiv = document.getElementById('colors');
let colorButtons = [];
palette.forEach(c => {
  const b = document.createElement('button');
  b.style.background = c;
  b.dataset.color = c;
  b.onclick = () => {
    currentColor = c;
    isEraser = false;
    colorButtons.forEach(btn => btn.classList.remove('selected'));
    b.classList.add('selected');
    eraserBtn.classList.remove('selected');
  };
  colorDiv.appendChild(b);
  colorButtons.push(b);
});

// Eraser
const eraserBtn = document.createElement('button');
eraserBtn.style.background = 'linear-gradient(135deg, #ddd, #aaa)';
eraserBtn.style.width = '100%';
eraserBtn.style.height = '42px';
eraserBtn.style.marginTop = '8px';
eraserBtn.innerHTML = 'ðŸ§¼ Radierer';
eraserBtn.onclick = () => {
  isEraser = true;
  colorButtons.forEach(btn => btn.classList.remove('selected'));
  eraserBtn.classList.add('selected');
};
colorDiv.appendChild(eraserBtn);

// Pixel Modus Button
const pixelModeBtn = document.createElement('button');
pixelModeBtn.className = 'control-btn';
pixelModeBtn.textContent = 'ðŸŽ¯ Pixel Modus';
pixelModeBtn.onclick = () => {
  isPixelMode = !isPixelMode;
  pixelModeBtn.textContent = isPixelMode ? 'ðŸŽ¯ Pixel Modus: AN (View locked)' : 'ðŸŽ¯ Pixel Modus';
  canvas.style.cursor = isPixelMode ? 'crosshair' : 'default';
  if (isPixelMode) {
    status.textContent = 'Pixel Modus aktiv â€“ View ist locked';
  } else {
    status.textContent = 'Pixel Modus deaktiviert';
  }
};
colorDiv.appendChild(pixelModeBtn);

// Player Info + Shop
const infoDiv = document.createElement('div');
infoDiv.style.marginTop = '16px';
infoDiv.innerHTML = `
  <div style="font-weight:bold; margin-bottom:8px; border-top:1px solid #eee; padding-top:10px;">Spieler</div>
  <div id="player-info">
    Level: <span id="lvl">1</span><br>
    Coins: <span id="coins">0</span><br>
    Pixels: <span id="placed">0</span> / <span id="maxp">10</span><br>
    Cooldown: <span id="cooldown">5.0s</span>
  </div>
  <div style="font-weight:bold; margin:12px 0 6px 0;">Upgrades</div>
  <button id="btn-max" class="control-btn">+5 Max Pixels (100 Coins)</button>
  <button id="btn-regen" class="control-btn">-1s Cooldown (50 Coins)</button>
`;
document.getElementById('gui').appendChild(infoDiv);

function updatePlayerInfo() {
  document.getElementById('lvl').textContent = userData.level || 1;
  document.getElementById('coins').textContent = userData.coins || 0;
  document.getElementById('placed').textContent = userData.placed || 0;
  document.getElementById('maxp').textContent = userData.maxPixels || 10;
  const cdSec = ((userData.cooldown || 5000) / 1000).toFixed(1);
  document.getElementById('cooldown').textContent = cdSec + 's';
}

// Upgrade Buttons
document.getElementById('btn-max').addEventListener('click', async () => {
  if (!userDocRef || !currentUser) return;
  const coins = userData.coins || 0;
  if (coins < 100) {
    status.textContent = 'Nicht genug Coins!';
    return;
  }
  try {
    await setDoc(userDocRef, {
      maxPixels: (userData.maxPixels || 10) + 5,
      coins: coins - 100
    }, { merge: true });
    status.textContent = 'Max Pixels +5 gekauft!';
  } catch (e) {
    status.textContent = 'Fehler beim Upgrade';
  }
});

document.getElementById('btn-regen').addEventListener('click', async () => {
  if (!userDocRef || !currentUser) return;
  const coins = userData.coins || 0;
  const cd = userData.cooldown || 5000;
  if (coins < 50) {
    status.textContent = 'Nicht genug Coins!';
    return;
  }
  if (cd <= 1000) {
    status.textContent = 'Cooldown schon minimal!';
    return;
  }
  try {
    await setDoc(userDocRef, {
      cooldown: cd - 1000,
      coins: coins - 50
    }, { merge: true });
    status.textContent = 'Cooldown -1s gekauft!';
  } catch (e) {
    status.textContent = 'Fehler beim Upgrade';
  }
});

// ===== Draw =====
function draw() {
  if (!isDirty) return requestAnimationFrame(draw);
  isDirty = false;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  ctx.fillStyle = "#e9f1ff";
  ctx.fillRect(WORLD_MIN*PIXEL, WORLD_MIN*PIXEL, (WORLD_MAX-WORLD_MIN+1)*PIXEL, (WORLD_MAX-WORLD_MIN+1)*PIXEL);

  if (scale > 0.4) {
    ctx.strokeStyle = scale > 1.8 ? "#d0d0d0" : "#e0e0e0";
    ctx.lineWidth = 1 / Math.max(scale, 0.5);
    const left = -offsetX / scale;
    const top = -offsetY / scale;
    const right = left + canvas.width / scale;
    const bottom = top + canvas.height / scale;
    const xStart = Math.floor(left / PIXEL) * PIXEL;
    const yStart = Math.floor(top / PIXEL) * PIXEL;
    for (let x = xStart; x <= right + PIXEL; x += PIXEL) {
      ctx.beginPath(); ctx.moveTo(x, top); ctx.lineTo(x, bottom); ctx.stroke();
    }
    for (let y = yStart; y <= bottom + PIXEL; y += PIXEL) {
      ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(right, y); ctx.stroke();
    }
  }

  const viewLeft = -offsetX / scale / PIXEL - 2;
  const viewRight = viewLeft + canvas.width / scale / PIXEL + 4;
  const viewTop = -offsetY / scale / PIXEL - 2;
  const viewBottom = viewTop + canvas.height / scale / PIXEL + 4;
  pixels.forEach((color, key) => {
    const [px, py] = key.split('_').map(Number);
    if (px < viewLeft || px > viewRight || py < viewTop || py > viewBottom) return;
    ctx.fillStyle = color;
    ctx.fillRect(px * PIXEL + 1, py * PIXEL + 1, PIXEL - 2, PIXEL - 2);
  });
  ctx.restore();
  requestAnimationFrame(draw);
}
draw();

// ===== Firebase Auth (Anonymous) =====
onAuthStateChanged(auth, (user) => {
  if (user) {
    currentUser = user;
    userDocRef = doc(db, "users", user.uid);
    getDoc(userDocRef).then(snap => {
      if (!snap.exists()) {
        setDoc(userDocRef, {
          level: 1,
          maxPixels: 10,
          placed: 0,
          coins: 0,
          cooldown: 5000,
          lastPlace: serverTimestamp()
        });
      }
    });
    onSnapshot(userDocRef, (snap) => {
      if (snap.exists()) {
        userData = snap.data();
        updatePlayerInfo();
      }
    });
  }
});
signInAnonymously(auth).catch(() => {});

// ===== Firebase Pixels =====
onSnapshot(collection(db, "pixels"), snap => {
  snap.docChanges().forEach(change => {
    const d = change.doc.data();
    const key = `${d.x}_${d.y}`;
    if (change.type === "removed") {
      pixels.delete(key);
    } else {
      pixels.set(key, d.color);
    }
  });
  isDirty = true;
});

// ===== Hilfsfunktionen =====
function screenToWorld(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (clientX - rect.left - offsetX) / scale / PIXEL,
    y: (clientY - rect.top - offsetY) / scale / PIXEL
  };
}

async function placePixel(clientX, clientY) {
  if (!currentUser || !userDocRef) {
    status.textContent = 'Warte auf Login...';
    return;
  }

  const {x, y} = screenToWorld(clientX, clientY);
  const ix = Math.round(x);
  const iy = Math.round(y);

  if (ix < WORLD_MIN || ix > WORLD_MAX || iy < WORLD_MIN || iy > WORLD_MAX) return;

  const id = `${ix}_${iy}`;
  const pixelRef = doc(db, "pixels", id);

  try {
    const pixelSnap = await getDoc(pixelRef);
    const pixelData = pixelSnap.exists() ? pixelSnap.data() : null;

    if (pixelData && pixelData.owner !== currentUser.uid) {
      status.textContent = 'Fremdes Pixel â€“ nicht Ã¼berschreibbar!';
      return;
    }

    const now = Date.now();
    const lastPlaceMs = userData.lastPlace && typeof userData.lastPlace.toMillis === 'function' 
      ? userData.lastPlace.toMillis() : (userData.lastPlace || 0);
    const cooldownMs = userData.cooldown || 5000;

    if (now - lastPlaceMs < cooldownMs) {
      const remaining = Math.ceil((cooldownMs - (now - lastPlaceMs)) / 1000);
      status.textContent = `Cooldown: noch ${remaining}s`;
      return;
    }

    if ((userData.placed || 0) >= (userData.maxPixels || 10)) {
      status.textContent = 'Max Pixelanzahl erreicht â€“ Upgrade kaufen!';
      return;
    }

    if (isEraser) {
      if (!pixelSnap.exists()) return;
      await deleteDoc(pixelRef);
      await setDoc(userDocRef, {
        placed: Math.max(0, (userData.placed || 0) - 1)
      }, { merge: true });
      status.textContent = 'Pixel entfernt';
    } else {
      await setDoc(pixelRef, {
        x: ix,
        y: iy,
        color: currentColor,
        owner: currentUser.uid,
        time: serverTimestamp()
      }, { merge: true });

      await setDoc(userDocRef, {
        placed: (userData.placed || 0) + 1,
        coins: (userData.coins || 0) + 1,
        lastPlace: serverTimestamp()
      }, { merge: true });

      status.textContent = 'Pixel platziert!';
    }
    isDirty = true;
  } catch (e) {
    console.error(e);
    status.textContent = 'Fehler beim Platzieren';
  }
}

// ===== Input (Mouse + Touch) =====
let isDrawing = false;

function handleDown(e) {
  e.preventDefault();
  isDrawing = true;
  const x = e.clientX || (e.touches && e.touches[0]?.clientX);
  const y = e.clientY || (e.touches && e.touches[0]?.clientY);
  if (x && y) placePixel(x, y);
}

function handleMove(e) {
  e.preventDefault();
  if (!isDrawing) return;
  const x = e.clientX || (e.touches && e.touches[0]?.clientX);
  const y = e.clientY || (e.touches && e.touches[0]?.clientY);
  if (x && y) placePixel(x, y);
}

canvas.addEventListener('mousedown', handleDown);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', () => isDrawing = false);
canvas.addEventListener('mouseleave', () => isDrawing = false);
canvas.addEventListener('touchstart', handleDown, {passive: false});
canvas.addEventListener('touchmove', handleMove, {passive: false});
canvas.addEventListener('touchend', () => isDrawing = false);

// Zoom (Wheel) â€“ disabled in Pixel Modus
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  if (isPixelMode) return;

  const delta = e.deltaY < 0 ? 1.16 : 0.86;
  const oldScale = scale;
  scale *= delta;
  scale = Math.max(0.12, Math.min(30, scale));

  const mx = e.clientX - canvas.getBoundingClientRect().left;
  const my = e.clientY - canvas.getBoundingClientRect().top;
  offsetX = mx - (mx - offsetX) * (scale / oldScale);
  offsetY = my - (my - offsetY) * (scale / oldScale);
  isDirty = true;
}, {passive: false});

// Pinch + Pan (Touch) â€“ pan/zoom disabled in Pixel Modus
let lastTouches = null;
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  lastTouches = [...e.touches];
}, {passive: false});

canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  const touches = e.touches;

  if (touches.length === 2 && lastTouches?.length === 2) {
    if (isPixelMode) {
      lastTouches = [...touches];
      return;
    }

    const [t1, t2] = touches;
    const [p1, p2] = lastTouches;
    const midX = (t1.clientX + t2.clientX)/2;
    const midY = (t1.clientY + t2.clientY)/2;
    const prevMidX = (p1.clientX + p2.clientX)/2;
    const prevMidY = (p1.clientY + p2.clientY)/2;
    const distOld = Math.hypot(p2.clientX-p1.clientX, p2.clientY-p1.clientY);
    const distNew = Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY);

    if (distOld > 12) {
      const zoom = distNew / distOld;
      const oldScale = scale;
      scale *= zoom ** 0.9;
      scale = Math.max(0.12, Math.min(30, scale));
      offsetX = midX - (midX - offsetX) * (scale / oldScale);
      offsetY = midY - (midY - offsetY) * (scale / oldScale);
    }
    offsetX += midX - prevMidX;
    offsetY += midY - prevMidY;
    isDirty = true;
    lastTouches = [...touches];
  }
}, {passive: false});

canvas.addEventListener("touchend", () => {
  lastTouches = null;
});

requestAnimationFrame(draw);
</script>
</body>
</html>
