<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <title>r-world – Pixel Art ohne Login</title>
  <style>
    body {
      margin:0; overflow:hidden; background:#f4f7fb;
      font-family: system-ui, sans-serif; color:#444;
    }
    #canvas {
      width:100vw; height:100vh; display:block;
      background:#e9f1ff; touch-action: none;
      -webkit-user-select: none;
    }
    #gui {
      position: fixed; top: 12px; left: 12px; z-index: 100;
      background: rgba(255,255,255,0.97);
      padding: 12px 16px;
      border-radius: 14px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      border: 1px solid #e0e0e0;
      min-width: 220px;
    }
    #colors {
      display: grid;
      grid-template-columns: repeat(4, 42px);
      gap: 10px;
      margin: 12px 0 8px;
    }
    #colors button {
      width: 42px; height: 42px;
      border: 3px solid #f0f0f0;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transition: all 0.14s;
    }
    #colors button:hover { transform: scale(1.12); border-color: #ccc; }
    #colors button.selected {
      border-color: #1a73e8;
      box-shadow: 0 0 0 3px rgba(26,115,232,0.25);
      transform: scale(1.08);
    }
    #status { font-size: 0.92rem; color: #666; min-height: 1.3em; }
  </style>
</head>
<body>

<div id="gui">
  <div><strong>Farbe</strong></div>
  <div id="colors"></div>
  <div id="status">Bereit zum Pixeln!</div>
</div>

<canvas id="canvas"></canvas>

<script type="module">
// ===== Firebase Setup (nur Lesen + Schreiben ohne Auth) =====
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, setDoc, deleteDoc, collection, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCXNvSbBsRVgyKJUmckxpm_WHhC6xflSTg",
  authDomain: "r-world-3879d.firebaseapp.com",
  projectId: "r-world-3879d",
  storageBucket: "r-world-3879d.appspot.com",
  messagingSenderId: "878075356607",
  appId: "1:878075356607:web:c2177f3904858d50626d0a"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// ===== Canvas & Vars =====
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');

const PIXEL = 32;
const WORLD_MIN = -400;
const WORLD_MAX = 400;

let currentColor = "#000000";
let isEraser = false;
const pixels = new Map(); // "x_y" → color

// Viewport
let scale = 1;
let offsetX = 0;
let offsetY = 0;
let isDirty = true;

// Resize
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  isDirty = true;
}
window.addEventListener('resize', resize);
resize();

// Farbpalette
const palette = ["#000","#fff","#f00","#0f0","#00f","#ff0","#f0f","#0ff","#fa0","#0fa","#a0f","#f80","#c71585","#32cd32","#4169e1","#808080"];
const colorDiv = document.getElementById('colors');
let colorButtons = [];

palette.forEach(c => {
  const b = document.createElement('button');
  b.style.background = c;
  b.dataset.color = c;
  b.onclick = () => {
    currentColor = c;
    isEraser = false;
    colorButtons.forEach(btn => btn.classList.remove('selected'));
    b.classList.add('selected');
  };
  colorDiv.appendChild(b);
  colorButtons.push(b);
});

// Eraser
const eraserBtn = document.createElement('button');
eraserBtn.style.background = 'linear-gradient(135deg, #ddd, #aaa)';
eraserBtn.innerHTML = 'Radierer';
eraserBtn.onclick = () => {
  isEraser = true;
  colorButtons.forEach(btn => btn.classList.remove('selected'));
  eraserBtn.classList.add('selected');
};
colorDiv.appendChild(eraserBtn);

// ===== Draw – optimiert für Performance =====
function draw() {
  if (!isDirty) return requestAnimationFrame(draw);
  isDirty = false;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  // Hintergrund
  ctx.fillStyle = "#e9f1ff";
  ctx.fillRect(WORLD_MIN*PIXEL, WORLD_MIN*PIXEL, (WORLD_MAX-WORLD_MIN+1)*PIXEL, (WORLD_MAX-WORLD_MIN+1)*PIXEL);

  // Grid – nur bei halbwegs sinnvollem Zoom
  if (scale > 0.4) {
    ctx.strokeStyle = scale > 1.8 ? "#d0d0d0" : "#e0e0e0";
    ctx.lineWidth = 1 / Math.max(scale, 0.5);

    const left   = -offsetX / scale;
    const top    = -offsetY / scale;
    const right  = left + canvas.width / scale;
    const bottom = top + canvas.height / scale;

    const xStart = Math.floor(left / PIXEL) * PIXEL;
    const yStart = Math.floor(top / PIXEL) * PIXEL;

    for (let x = xStart; x <= right + PIXEL; x += PIXEL) {
      ctx.beginPath(); ctx.moveTo(x, top); ctx.lineTo(x, bottom); ctx.stroke();
    }
    for (let y = yStart; y <= bottom + PIXEL; y += PIXEL) {
      ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(right, y); ctx.stroke();
    }
  }

  // Pixel – nur sichtbare zeichnen, kein Schatten
  const viewLeft   = -offsetX / scale / PIXEL - 2;
  const viewRight  = viewLeft + canvas.width / scale / PIXEL + 4;
  const viewTop    = -offsetY / scale / PIXEL - 2;
  const viewBottom = viewTop + canvas.height / scale / PIXEL + 4;

  pixels.forEach((color, key) => {
    const [px, py] = key.split('_').map(Number);
    if (px < viewLeft || px > viewRight || py < viewTop || py > viewBottom) return;
    ctx.fillStyle = color;
    ctx.fillRect(px * PIXEL + 1, py * PIXEL + 1, PIXEL - 2, PIXEL - 2);
  });

  ctx.restore();
  requestAnimationFrame(draw);
}
draw();

// ===== Firebase =====
onSnapshot(collection(db, "pixels"), snap => {
  snap.docChanges().forEach(change => {
    const d = change.doc.data();
    const key = `${d.x}_${d.y}`;
    if (change.type === "removed") {
      pixels.delete(key);
    } else {
      pixels.set(key, d.color);
    }
  });
  isDirty = true;
});

// ===== Hilfsfunktionen =====
function screenToWorld(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (clientX - rect.left - offsetX) / scale / PIXEL,
    y: (clientY - rect.top - offsetY) / scale / PIXEL
  };
}

function placePixel(clientX, clientY) {
  const {x, y} = screenToWorld(clientX, clientY);
  const ix = Math.round(x);
  const iy = Math.round(y);

  if (ix < WORLD_MIN || ix > WORLD_MAX || iy < WORLD_MIN || iy > WORLD_MAX) return;

  const id = `${ix}_${iy}`;

  if (isEraser) {
    deleteDoc(doc(db, "pixels", id)).catch(() => {});
    status.textContent = 'Pixel entfernt';
  } else {
    setDoc(doc(db, "pixels", id), {
      x: ix,
      y: iy,
      color: currentColor,
      time: serverTimestamp()
    }, {merge: true}).catch(() => {});
  }

  isDirty = true;
}

// ===== Input (Mouse + Touch) =====
let isDrawing = false;

function handleDown(e) {
  e.preventDefault();
  isDrawing = true;
  const x = e.clientX || (e.touches && e.touches[0]?.clientX);
  const y = e.clientY || (e.touches && e.touches[0]?.clientY);
  if (x && y) placePixel(x, y);
}

function handleMove(e) {
  e.preventDefault();
  if (!isDrawing) return;
  const x = e.clientX || (e.touches && e.touches[0]?.clientX);
  const y = e.clientY || (e.touches && e.touches[0]?.clientY);
  if (x && y) placePixel(x, y);
}

canvas.addEventListener('mousedown', handleDown);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup',   () => isDrawing = false);
canvas.addEventListener('mouseleave',() => isDrawing = false);

canvas.addEventListener('touchstart', handleDown, {passive:false});
canvas.addEventListener('touchmove',  handleMove, {passive:false});
canvas.addEventListener('touchend',   () => isDrawing = false);

// ===== Zoom (Mausrad) =====
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const delta = e.deltaY < 0 ? 1.16 : 0.86;
  const oldScale = scale;
  scale *= delta;
  scale = Math.max(0.12, Math.min(30, scale));

  const mx = e.clientX - canvas.getBoundingClientRect().left;
  const my = e.clientY - canvas.getBoundingClientRect().top;

  offsetX = mx - (mx - offsetX) * (scale / oldScale);
  offsetY = my - (my - offsetY) * (scale / oldScale);

  isDirty = true;
}, {passive: false});

// ===== Pinch Zoom + Pan =====
let lastTouches = null;

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  lastTouches = [...e.touches];
}, {passive: false});

canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  const touches = e.touches;

  if (touches.length === 1 && !isDrawing) {
    placePixel(touches[0].clientX, touches[0].clientY);
  }
  else if (touches.length === 2 && lastTouches?.length === 2) {
    const [t1, t2] = touches;
    const [p1, p2] = lastTouches;
    const midX = (t1.clientX + t2.clientX)/2;
    const midY = (t1.clientY + t2.clientY)/2;
    const prevMidX = (p1.clientX + p2.clientX)/2;
    const prevMidY = (p1.clientY + p2.clientY)/2;

    const distOld = Math.hypot(p2.clientX-p1.clientX, p2.clientY-p1.clientY);
    const distNew = Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY);

    if (distOld > 12) {
      const zoom = distNew / distOld;
      const oldScale = scale;
      scale *= zoom ** 0.9;
      scale = Math.max(0.12, Math.min(30, scale));
      offsetX = midX - (midX - offsetX) * (scale / oldScale);
      offsetY = midY - (midY - offsetY) * (scale / oldScale);
    }

    offsetX += midX - prevMidX;
    offsetY += midY - prevMidY;

    isDirty = true;
    lastTouches = [...touches];
  }
}, {passive: false});

canvas.addEventListener("touchend", () => {
  if (e.touches.length < 2) lastTouches = null;
});

requestAnimationFrame(draw);
</script>
</body>
</html>
